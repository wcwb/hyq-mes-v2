---
description: TypeScript æµ‹è¯•æ¨¡å¼è§„åˆ™
globs: 
alwaysApply: false
---
# TypeScript æµ‹è¯•æ¨¡å¼è§„åˆ™

> åŸºäºå­ä»»åŠ¡5.2ç»éªŒæ€»ç»“çš„TypeScriptæµ‹è¯•æœ€ä½³å®è·µ

## ğŸ¯ ç±»å‹å®‰å…¨æµ‹è¯•æ ¸å¿ƒåŸåˆ™

### 1. ç¼–è¯‘æ—¶ + è¿è¡Œæ—¶åŒé‡éªŒè¯
```typescript
// âœ… å¥½çš„åšæ³•ï¼šç¼–è¯‘æ—¶ç±»å‹ + è¿è¡Œæ—¶éªŒè¯
it('type safety validation', () => {
  const instance: ExpectedInterface = createInstance() // ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥
  
  // è¿è¡Œæ—¶ç±»å‹éªŒè¯
  expect(typeof instance.method).toBe('function')
  expect(typeof instance.property).toBe('string')
  expect(Array.isArray(instance.list)).toBe(true)
})
```

### 2. æ³›å‹ç±»å‹æµ‹è¯•æ¨¡å¼
```typescript
// æ³›å‹composableæµ‹è¯•
describe('generic composable', () => {
  it('should work with string type', () => {
    const instance = useGenericComposable<string>()
    
    // ç±»å‹æ–­è¨€ + è¿è¡Œæ—¶éªŒè¯
    const result: string = instance.getValue()
    expect(typeof result).toBe('string')
  })
  
  it('should work with number type', () => {
    const instance = useGenericComposable<number>()
    
    const result: number = instance.getValue()
    expect(typeof result).toBe('number')
  })
})
```

## ğŸ” å“åº”å¼ç±»å‹æµ‹è¯•æ¨¡å¼

### Vue 3 å“åº”å¼å±æ€§ç±»å‹éªŒè¯
```typescript
import type { Ref, ComputedRef } from 'vue'

describe('reactive types', () => {
  it('should return correct reactive types', () => {
    const composable = useComposable()
    
    // Ref ç±»å‹éªŒè¯
    const refValue: Ref<string> = composable.refProperty
    expect(refValue.value).toBeDefined()
    expect(typeof refValue.value).toBe('string')
    
    // ComputedRef ç±»å‹éªŒè¯  
    const computedValue: ComputedRef<boolean> = composable.computedProperty
    expect(computedValue.value).toBeDefined()
    expect(typeof computedValue.value).toBe('boolean')
    
    // åªè¯»å¯¹è±¡éªŒè¯
    const config: Readonly<ConfigType> = composable.config
    expect(typeof config.storageKey).toBe('string')
    expect(typeof config.version).toBe('string')
  })
})
```

### å¸¸è§å“åº”å¼ç±»å‹è¯†åˆ«æ¨¡å¼
```typescript
// ç±»å‹è¯†åˆ«è¾…åŠ©å‡½æ•°
const isRef = (value: any): value is Ref => {
  return value && typeof value === 'object' && 'value' in value
}

const isComputed = (value: any): value is ComputedRef => {
  return isRef(value) && value.effect !== undefined
}

const isReactive = (value: any): value is ReactiveObject => {
  return value && typeof value === 'object' && !isRef(value)
}

// æµ‹è¯•ä¸­ä½¿ç”¨
it('should identify reactive types correctly', () => {
  const composable = useComposable()
  
  expect(isRef(composable.refProperty)).toBe(true)
  expect(isComputed(composable.computedProperty)).toBe(true)
  expect(isReactive(composable.reactiveObject)).toBe(true)
})
```

## ğŸ›¡ï¸ æ¥å£å¥‘çº¦æµ‹è¯•æ¨¡å¼

### 1. ä¸¥æ ¼æ¥å£éªŒè¯
```typescript
interface ExpectedComposableAPI {
  // æ–¹æ³•ç­¾å
  saveState: (data: any[], activeId: string | null) => Promise<boolean>
  loadState: () => Promise<StateType | null>
  clearState: () => Promise<boolean>
  
  // å“åº”å¼å±æ€§
  hasValidData: ComputedRef<boolean>
  isExpired: ComputedRef<boolean>
  syncErrors: Readonly<Ref<Error[]>>
  
  // é…ç½®å¯¹è±¡
  config: Readonly<ConfigType>
}

it('should implement expected API contract', () => {
  const composable = useComposable()
  
  // éªŒè¯æ–¹æ³•å­˜åœ¨ä¸”ç±»å‹æ­£ç¡®
  expect(typeof composable.saveState).toBe('function')
  expect(typeof composable.loadState).toBe('function')
  expect(typeof composable.clearState).toBe('function')
  
  // éªŒè¯å“åº”å¼å±æ€§
  expect(composable.hasValidData.value).toBeDefined()
  expect(composable.isExpired.value).toBeDefined()
  expect(Array.isArray(composable.syncErrors.value)).toBe(true)
  
  // éªŒè¯é…ç½®å¯¹è±¡
  expect(typeof composable.config).toBe('object')
  expect(typeof composable.config.storageKey).toBe('string')
})
```

### 2. æ–¹æ³•ç­¾åéªŒè¯æ¨¡å¼
```typescript
// æ–¹æ³•å‚æ•°ç±»å‹éªŒè¯
it('should accept correct parameter types', async () => {
  const composable = useComposable()
  
  // æ­£ç¡®çš„å‚æ•°ç±»å‹åº”è¯¥æˆåŠŸ
  const validData: TabItem[] = [{ id: '1', title: 'Test', route: '/test' }]
  const result = await composable.saveState(validData, 'active-id')
  expect(typeof result).toBe('boolean')
  
  // TypeScript åº”è¯¥åœ¨ç¼–è¯‘æ—¶æ•è·é”™è¯¯å‚æ•°
  // composable.saveState('invalid', 123) // ç¼–è¯‘é”™è¯¯
})

// è¿”å›å€¼ç±»å‹éªŒè¯
it('should return correct types', async () => {
  const composable = useComposable()
  
  const saveResult = await composable.saveState([], null)
  expect(typeof saveResult).toBe('boolean')
  
  const loadResult = await composable.loadState()
  expect(loadResult === null || typeof loadResult === 'object').toBe(true)
  
  if (loadResult !== null) {
    expect(Array.isArray(loadResult.tabs)).toBe(true)
    expect(typeof loadResult.activeTabId === 'string' || loadResult.activeTabId === null).toBe(true)
  }
})
```

## ğŸ”§ ç±»å‹å®ˆå«æµ‹è¯•æ¨¡å¼

### è‡ªå®šä¹‰ç±»å‹å®ˆå«
```typescript
// ç±»å‹å®ˆå«å®šä¹‰
const isTabItem = (item: any): item is TabItem => {
  return (
    typeof item === 'object' &&
    typeof item.id === 'string' &&
    typeof item.title === 'string' &&
    typeof item.route === 'string' &&
    typeof item.lastAccessed === 'number' &&
    typeof item.createdAt === 'number'
  )
}

// ç±»å‹å®ˆå«æµ‹è¯•
describe('type guards', () => {
  it('should correctly identify valid TabItem', () => {
    const validTab: TabItem = {
      id: 'test-id',
      title: 'Test Tab',
      route: '/test',
      lastAccessed: Date.now(),
      createdAt: Date.now()
    }
    
    expect(isTabItem(validTab)).toBe(true)
  })
  
  it('should reject invalid objects', () => {
    const invalidTab = { id: 'test', title: 123 } // titleåº”è¯¥æ˜¯string
    expect(isTabItem(invalidTab)).toBe(false)
  })
})
```

### è¿è¡Œæ—¶ç±»å‹éªŒè¯å™¨
```typescript
// é€šç”¨ç±»å‹éªŒè¯å™¨
const validateObjectShape = <T>(
  obj: any, 
  schema: Record<keyof T, string>
): obj is T => {
  return Object.entries(schema).every(([key, expectedType]) => {
    const actualType = typeof obj[key]
    return actualType === expectedType
  })
}

// ä½¿ç”¨ç¤ºä¾‹
it('should validate object shapes', () => {
  const testObject = {
    name: 'test',
    age: 25,
    active: true
  }
  
  const isValid = validateObjectShape<{
    name: string
    age: number  
    active: boolean
  }>(testObject, {
    name: 'string',
    age: 'number',
    active: 'boolean'
  })
  
  expect(isValid).toBe(true)
})
```

## ğŸ“Š ç±»å‹é”™è¯¯è°ƒè¯•æ¨¡å¼

### 1. ç±»å‹ä¿¡æ¯æå–å™¨
```typescript
// è°ƒè¯•ç±»å‹ä¿¡æ¯çš„è¾…åŠ©å·¥å…·
const getTypeInfo = (value: any) => ({
  type: typeof value,
  constructor: value?.constructor?.name,
  isArray: Array.isArray(value),
  isNull: value === null,
  isUndefined: value === undefined,
  keys: typeof value === 'object' ? Object.keys(value || {}) : []
})

it('debug type information', () => {
  const composable = useComposable()
  
  console.log('Composable structure:', getTypeInfo(composable))
  console.log('hasValidData:', getTypeInfo(composable.hasValidData))
  console.log('config:', getTypeInfo(composable.config))
  
  // åŸºäºè¾“å‡ºä¿¡æ¯è°ƒæ•´æµ‹è¯•æ–­è¨€
})
```

### 2. ç±»å‹å…¼å®¹æ€§æµ‹è¯•
```typescript
// æµ‹è¯•ç±»å‹å…¼å®¹æ€§
describe('type compatibility', () => {
  it('should be compatible with expected interfaces', () => {
    const composable = useComposable()
    
    // å°è¯•èµ‹å€¼ç»™æœŸæœ›çš„æ¥å£ç±»å‹
    const api: ExpectedAPI = composable // ç¼–è¯‘æ—¶æ£€æŸ¥
    
    // è¿è¡Œæ—¶éªŒè¯å…³é”®å±æ€§
    expect(api.saveState).toBeDefined()
    expect(api.loadState).toBeDefined()
  })
  
  it('should handle optional properties correctly', () => {
    interface OptionalProps {
      required: string
      optional?: number
    }
    
    const testObj: OptionalProps = { required: 'test' }
    
    expect(testObj.required).toBe('test')
    expect(testObj.optional).toBeUndefined()
  })
})
```

## ğŸ¯ é…ç½®å¯¹è±¡ç±»å‹æµ‹è¯•

### é…ç½®éªŒè¯æ¨¡å¼
```typescript
// é…ç½®å¯¹è±¡ç±»å‹æµ‹è¯•
describe('configuration types', () => {
  it('should accept valid configuration', () => {
    const validConfig: ConfigType = {
      storageKey: 'test-key',
      version: '1.0.0',
      autoSync: true,
      expireTime: 1000
    }
    
    const composable = useComposable(validConfig)
    expect(composable.config.storageKey).toBe('test-key')
  })
  
  it('should handle partial configuration', () => {
    const partialConfig: Partial<ConfigType> = {
      storageKey: 'partial-key'
    }
    
    const composable = useComposable(partialConfig)
    expect(composable.config.storageKey).toBe('partial-key')
    // å…¶ä»–å±æ€§åº”è¯¥ä½¿ç”¨é»˜è®¤å€¼
  })
  
  it('should merge with defaults correctly', () => {
    const composable = useComposable({ storageKey: 'custom' })
    
    // è‡ªå®šä¹‰å€¼
    expect(composable.config.storageKey).toBe('custom')
    
    // é»˜è®¤å€¼
    expect(typeof composable.config.version).toBe('string')
    expect(typeof composable.config.autoSync).toBe('boolean')
  })
})
```

## ğŸ“‹ TypeScriptæµ‹è¯•æ£€æŸ¥æ¸…å•

### ç¼–è¯‘æ—¶æ£€æŸ¥
- [ ] æ‰€æœ‰ç±»å‹æ³¨è§£æ­£ç¡®
- [ ] æ³›å‹ä½¿ç”¨æ°å½“
- [ ] æ¥å£å®ç°å®Œæ•´
- [ ] ç±»å‹å¯¼å…¥æ­£ç¡®

### è¿è¡Œæ—¶éªŒè¯
- [ ] å“åº”å¼å±æ€§ç±»å‹éªŒè¯ï¼ˆ.valueè®¿é—®ï¼‰
- [ ] æ–¹æ³•è¿”å›å€¼ç±»å‹éªŒè¯
- [ ] é…ç½®å¯¹è±¡ç»“æ„éªŒè¯
- [ ] é”™è¯¯å¤„ç†ç±»å‹å®‰å…¨

### å…¼å®¹æ€§æ£€æŸ¥
- [ ] æ¥å£å¥‘çº¦ç¬¦åˆé¢„æœŸ
- [ ] å¯é€‰å±æ€§å¤„ç†æ­£ç¡®
- [ ] ç±»å‹å®ˆå«å·¥ä½œæ­£å¸¸
- [ ] æ³›å‹çº¦æŸæœ‰æ•ˆ

## ğŸš€ æœ€ä½³å®è·µæ€»ç»“

1. **åŒé‡éªŒè¯**ï¼šç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥ + è¿è¡Œæ—¶ç±»å‹éªŒè¯
2. **æ¸è¿›å¼éªŒè¯**ï¼šä»åŸºç¡€ç±»å‹åˆ°å¤æ‚æ¥å£
3. **ç±»å‹å®ˆå«**ï¼šä½¿ç”¨ç±»å‹å®ˆå«ç¡®ä¿è¿è¡Œæ—¶ç±»å‹å®‰å…¨
4. **è°ƒè¯•å‹å¥½**ï¼šæä¾›ç±»å‹ä¿¡æ¯æå–å·¥å…·
5. **æ–‡æ¡£åŒæ­¥**ï¼šç¡®ä¿ç±»å‹å®šä¹‰ä¸å®é™…è¡Œä¸ºä¸€è‡´

è¿™äº›æ¨¡å¼å°†å¸®åŠ©åˆ›å»ºç±»å‹å®‰å…¨ä¸”å¯é çš„TypeScriptæµ‹è¯•å¥—ä»¶ã€‚ 